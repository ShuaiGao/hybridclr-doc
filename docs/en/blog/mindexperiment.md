# A thought experiment on the feasibility of hybridclr

Before determining the goal and realizing hybridclr by hand, there is a question that must be considered - how do we determine the feasibility of hybridclr?

Although il2cpp is not an extremely complete runtime, the code is still as high as 12w lines, and the complexity is quite high. It is very difficult to understand its implementation in a short period of time. Except for several official blogs introducing il2cpp, there are almost no other documents,
Moreover, the implementation complexity of `Hybrid mode execution` is also very high. It is absolutely necessary to be sure that this plan is extremely feasible before starting to sharpen the knife without mistakenly chopping wood.

Based on our understanding of the CLR runtime, to implement the `hybrid mode execution` mechanism, at least the following problems must be solved

- Be able to dynamically register metadata, and these dynamically registered metadata must be completely equivalent to AOT metadata at runtime.
- All paths that call functions in dynamically loaded assemblies are directed to the correct interpreter implementation. Including virtual function override, delegate callback, reflection call, etc.
- The gc in the interpreter must be able to be processed uniformly with the gc in the AOT part.
- Multithreading related to work properly. Including but not limited to creating Thread, async, volatile, ThreadStatic, etc.

We analyze and solve these problems one by one below.

## Dynamic registration metadata

We roughly analyzed the code related to il2cpp metadata initialization and came to the following conclusions.

First of all, it is not feasible to dynamically modify globalmetadata.dat. Because globalmetadata.dat saves persistent metadata, a large number of ids are used to refer to each other between metadata. Adding new data is easy to introduce errors and become extremely difficult to detect bugs. In addition, there are many data items in globalmetadata because there are no documents, so it is impossible to analyze the actual use, and it is not known how to set the correct value. In addition, new dlls are dynamically loaded at runtime, and recalculating globalmetadata.dat is a costly affair. Moreover, metadata management in il2cpp does not support secondary loading, and repeated loading of globalmetadata.dat will cause considerable code changes.

A more feasible method is to modify the underlying functions of all metadata access, check the type of metadata being accessed, if it is AOT metadata, keep the previous call, if it comes from dynamic loading, then jump to the metadata management module of hybridclr , returning an appropriate value. But there is another problem here. Secondly, in order to optimize the performance of globalmetadata, the metadata in all dlls are under the unified id namespace. Many metadata query operations only use an id parameter. How to distinguish whether it is AOT or interpreter metadata based on the id?

We found that the values of these metadata ids in the globalmetadata.dat generated by the actual project are all small, and the maximum is no more than hundreds of thousands. After thinking, use a trick: we divide the id into two parts: the high bit is the image id, the low bit is the actual id, and image id=0 is reserved for AOT metadata. We assign an image id to each dynamically loaded dll, and the high bits of all metadata ids parsed from this image are the corresponding image ids.

We use this trick to hook all the methods of accessing metadata at the bottom. About dozens of places have been modified, basically the code is as follows, try not to modify the original logic, it is easy to ensure correctness.

```cpp
const char* il2cpp::vm::GlobalMetadata::GetStringFromIndex(StringIndex index)
{
     // ==={{ hybridclr
     if (hybridclr::metadata::IsInterpreterIndex(index))
     {
         return hybridclr::metadata::MetadataModule::GetStringFromEncodeIndex(index);
     }
     // ===}} hybridclr
     IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->stringSize);
     const char* strings = MetadataOffset<const char*>(s_GlobalMetadata, s_GlobalMetadataHeader->stringOffset, index);
     #if __ENABLE_UNITY_PLUGIN__
         if (g_get_string != NULL)
         {
             g_get_string((char*)strings, index);
         }
     #endif // __ENABLE_UNITY_PLUGIN__
         return strings;
}

```

We checked a number of related functions before doing it, and there are basically no problems. Although it is not sure that this is feasible, but metadata loading is the first stage of hybridclr development tasks, in case of problems, the loss of timely suspension of hybridclr development is not great. So we think that the first problem has been solved.

## All paths that call functions in dynamically loaded assemblies can be directed to the correct interpreter implementation

We analyzed the management method of Method metadata in il2cpp, and found that the MethodInfo structure stores function pointers that actually execute logic at runtime. If we simply set the pointer of the MethodInfo structure of the dynamically loaded function metadata to the correct interpreter function, can it be guaranteed that all calls to this function by the process can be correctly directed to the interpreter function?

The conclusion after careful consideration is affirmative. First of all, it is impossible for the AOT part to directly call the functions in the dynamically loaded dll. Second, there is nowhere else to store function pointers at runtime. It means that if you want to call a dynamically loaded function, you must obtain the function pointer in MethodInfo to execute the target function correctly. It means that all calls to this function during our operation will definitely call the correct interpreter function.

As for the second problem we solved.

## The gc in the interpreter must be able to be processed uniformly with the gc in the AOT part

It is easy to observe that managed objects can be allocated through il2cpp::vm::Object::New, and some memory that can be automatically managed by gc can be allocated through the functions of the gc module. But how can we guarantee that the correctness can be preserved by using this method? Will there be special rules of use, and the interpreter code of hybridclr cannot work with it?

Considering that there are many gc-related operations in the AOT code, we checked some c++ codes generated by il2cpp for these operations, and they all simply call functions such as il2cpp::vm::Object::New without special place. It can be analyzed in this way: the code generated by il2cpp is ordinary C++ code, and the hybridclr interpreter code is also C++ code. Since the memory usage of the generated code can work correctly, then the gc-related code in the hybridclr interpreter must also work correctly.

So far, we have solved the third problem.

## Multi-thread related code can work normally

Similar to the previous question. We checked the c++ code generated by il2cpp and found that it can run normally in a multi-threaded environment without any special features. Then we can be very sure that as long as the code of the hybridclr interpreter meets the requirements of conventional multi-threading, it can also run in multiple threads. It runs normally in a threaded environment.

So far, we have solved the fourth problem.

## Summarize

Through a small amount of observation of the actual il2cpp code, as well as the understanding of the principle of CLR runtime, combined with thought experiments, we can be more than 99.9% sure. Since the code generated by il2cpp can run correctly at runtime, then execute it in hybridclr interpretation mode The code also runs correctly.

The moment we completed the thought experiment, it was hard to hide our inner excitement. As an IT person majoring in physics, when Einstein was thinking about general relativity, he used the elevator thought experiment to get the amazing conclusion that gravity bends space-time. We dare not stand up to such great scientists, but we do use similar thinking skills. It can be said that hybridclr is not a simple summary of experience, but the result of profound insight and analytical ability.
