# 离线指令优化

:::warning

离线指令优化技术正开发中，目前仅可使用旧版本指令优化技术（即原来的标准指令优化技术）。
:::

离线指令优化（Offline Instruction Optimization，简称OIO）离线将原始IL指令转换为自定义的寄存器指令。
由于离线没有编译性能限制，可以使用更丰富的编译优化技术，极大提升了解释模块的性能。

优化后的指令执行性能整体提升100%-1000%（没看错，10倍以上）甚至更高，尤其是数值指令整体提升近300%。
而且由于已经提前转换，加载和指令翻译过程更快，卡顿更小。

离线指令优化技术支持代码加固方案中的虚拟化技术，极大提升了代码安全。

## 实现

高级指令优化技术包含了以下优化技术：

- 彻底的无用栈指令消除。消除掉所有不必要的栈操作
- 窥孔优化
- 常量复制优化
- 局部复制传播优化
- 全局复制传播优化
- 解释函数inline
- AOT函数inline（专利技术）
- 提供更多instinct指令，大幅提升常见的指令组合性能
- 条件检查消除技术。消除不必要的空指针检查、类型强转检查、数组越界检查
- CheckOnce运行时检查动态消除优化。例如访问静态成员变量的指令，在第2次执行时不再检查类型是否已经初始化过
- 其他优化


## 性能

TODO。

## 标准指令优化技术（将废弃）

标准指令优化技术为运行时优化技术。对常见的代码范式进行谨慎可靠的优化，大幅提升了变量访问（50%-100%）、数值计算（100-300%）、对象访问（50-200%）等常见指令的性能，像一些特殊代码如typeof指令的性能，提升了1000%以上。

由于运行时的时间及内存限制，标准指令优化只做一些无用栈消除、窥孔优化等等简单但较可靠的优化，无法执行一些复杂的优化。但由于IL指令是栈指令，即使只做了一些不复杂的常见优化，性能相比于社区的未优化版本也有显著提升。


以下是标准指令优化相比于社区版本的解释性能提升数据（0表示性能持平，n表示提升n倍）。

![interpreter_optimization](/img/hybridclr/interpreter_optimization.jpg)

以下是数值计算方面原生与标准指令优化的性能对比，纵坐标为耗时。标准指令优化的加法大约为原生7-16倍左右，乘法是4倍，除法是2倍。

![benchmark_numeric](/img/hybridclr/benchmark_numeric.jpg)
