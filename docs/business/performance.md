# 性能数据


比较粗糙地介绍这几种优化技术之间的性能差距。以数值计算为例，如果社区版的性能基准为1，则初级指令优化为2-4、深度指令优化为3-4、DHE为 50、原生为 50。

## 初级指令优化

在运行时的Transform过程中对常见的代码范式进行谨慎可靠的优化，大幅提升了变量访问（50%-100%）、数值计算（100-300%）、对象访问（50-200%）等常见指令的性能，像一些特殊代码如typeof指令的性能，提升了1500%以上。

由于运行时的时间及内存限制，初级指令优化只做一些无用栈消除、窥孔优化等等简单但较可靠的优化，无法执行一些复杂的优化。但由于IL指令是栈指令，即使只做了一些不复杂的常见优化，性能相比于社区的未优化版本也有巨幅提升。

以下是初级指令优化相比于社区版本的解释性能提升数据（0表示性能持平，n表示提升n倍）。

![interpreter_optimization](/img/hybridclr/interpreter_optimization.jpg)

以下是数值计算方面原生与初级指令优化的性能对比，纵坐标为耗时。初级指令优化的加法大约为原生7-16倍左右，乘法是4倍，除法是2倍。

![benchmark_numeric](/img/hybridclr/benchmark_numeric.jpg)


## 深度指令优化

相比于初级指令优化深度指令优化由于离线完成，可以执行一些深度复杂的优化，并且由于可以访问原始AOT程序集，甚至还能做一些运行时完全做不到的优化（例如将AOT的属性访问由函数调用优化为属性访问）。深度指令优化在数值计算方面相比基础指令优化差距不大，但综合差距明显（提升50-1000%）。

由于已经离线完成指令转换，深度指令优化另一优点是加载更快。

深度指令优化包含以下优化：

- 更彻底的栈消除优化，几乎优化掉所有不必要的压栈退栈操作
- inline 优化，不仅可以inline热更新函数，还能inline AOT函数
- 局部及全局的复制传播优化
- 无用代码消除
- 常量复制传播
- 公共表达式优化
- 更丰富的窥孔优化
- 其他优化

实际性能数据在测试中。

## DHE技术

如果函数未发生变化，则跟原生性能完全相同，DHE并不会额外增加性能开销。如果函数发生变化，则根据使用者的选择，性能相当于初级或者深度指令优化。根据目前已经接入的商业项目的测试数据来看，使用DHE技术后，热更新实际运行性能基本跟原生持平。

例如某个重度计算的项目用社区版本后，帧率由40多降到20多，卡顿明显。在引入DHE技术后，未发生任何更新前，帧率持平甚至更高一些（这是测试波动引起），进行热更新后，帧率由44降到42，大约下降了5%。这实际表现符合我们的理论估计。

